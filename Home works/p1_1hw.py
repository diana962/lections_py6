# Изменение строк
# name = 'Hello'
# name.replace('H', 'D')
# print(name.replace('H', 'D'))
# print(name[:1] + 'o' + name[2:])
# .split(sep=None) делит строку на список из подстрок.
# .replace(old, new) возвращает копию строки, в которой все вхождения подстроки заменены другой подстрокой.


# Методы похожи на функции. Метод — специализированный тип вызываемой процедуры, тесно связанный с объектом.
# Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается только вместе с определенным объектом и знает о нем во время выполнения.
# obj.foo(<args>)

# name = 'Hello world'
# name.capitalize() #Hello world
# name.lower() # hello world
# name.swapcase() #hELLO WORLD
# name.title() #Hello world
# name.upper() #HELLO WORLD
# print(name.capitalize(), name.swapcase(), name.lower(), name.title(),name.upper())


# Методы
# s = 'sun'
# s.count(<sub>) #возвращает количество точных вхождений подстроки <sub> в s.
# s.startswith(<suffix>) #возвращает, True если s начинается с указанного <suffix> и False если нет.
# s.endswith(<suffix>) #возвращает, True если s заканчивается указанным <suffix> и False если нет.
# s.find(<sub>) #возвращает первый индекс в s который соответствует началу строки <sub> (Этот метод возвращает, -1 если указанная подстрока не найдена)
# string.index(<sub>) – этот метод идентичен .find(), за исключением того, что он вызывает исключение ValueError, если <sub> не найден:
# s.isalnum() возвращает True, если строка s не пустая, а все ее символы буквенно-цифровые (либо буква, либо цифра). В другом случае False:
# s.isalpha() возвращает True, если строка s не пустая, а все ее символы буквенные. В другом случае False:
# s.digit() возвращает True когда строка s не пустая и все ее символы являются цифрами, а в False если нет:
# s.isidentifier() возвращает True, если s валидный идентификатор (название переменной, функции, класса и т.д.) python, а в False если нет:
# s.islower() возвращает True, если строка s не пустая, и все содержащиеся в нем буквенные символы строчные, а False если нет. Не алфавитные символы игнорируются:
# s.isprintable() возвращает, True если строка s пустая или все буквенные символы которые она содержит можно вывести на экран. Возвращает, False если s содержит хотя бы один специальный символ. Не алфавитные символы игнорируются:
# s.isspace() возвращает True, если s не пустая строка, и все символы являются пробельными, а False, если нет. Наиболее часто встречающиеся пробельные символы — это пробел ' ', табуляция '\t' и новая строка '\n':
# s.istitle() возвращает True когда s не пустая строка и первый алфавитный символ каждого слова в верхнем регистре, а все остальные буквенные символы в каждом слове строчные. Возвращает False, если нет:
# s.isupper() возвращает True, если строка s не пустая, и все содержащиеся в ней буквенные символы являются заглавными, и в False, если нет. Не алфавитные символы игнорируются:

# https://docs.python.org/3/library/string.html


# Как создать список?
# Списки объявляются в квадратных скобках [ ].
# z = [3, 7, 4, 2] # Создание списка
# heterogenousElements = [3, True, 'Вииитяяя', 2.0] 
# heterogenousElements = list((3, True, 'Вииитяяя', 2.0))  # обратите внимание на двойные круглые скобки 

# Срезы(slice) списка
# z = [3, 7, 4, 2]
# # Вывод элементов с индексом от 0 до 2 (не включая 2)
# print(z[0:2]) # 3, 7
# z = [4, 1, 5, 4, 10, 4]
# print(z.index(4)) # 0
# z = [4, 1, 5, 4, 10, 4]
# print(z.index(4, 3)) # 3 # он начинает искать 4 с 3ей позиции.

# [x]
# .count(x) # количество повторяющихся x
# .sort(). 

# Метод extend расширяет список, добавляя элементы. Преимущество над append в том, что вы можете добавлять списки.
# Добавим [4, 5] в конец z:
# z = [7, 3, 3]
# z.extend([4,5])
# print(z)
# [7, 3, 3, 4, 5]

# z = [7, 3, 3, 4, 5]
# z.insert(4, [1, 2])
# print(z)
# [7, 3, 3, 4, [1, 2], 5]

# x in s               True если элемент x находится в списке s
# x not in s           True если элемент x не находится в списке s
# s1 + s2              Объединение списков s1 и s2
# s * n , n * s        Копирует список s n раз
# len(s)               Длина списка s, т.e. количество элементов в s
# min(s)               Наименьший элемент списка s
# max(s)
# sum(s)               Сумма чисел списка s
# for i in list()      Перебирает элементы слева направо в цикле for

# Создание словаря
# Для создания словаря в Python необходимо передать последовательность элементов внутри фигурных скобок {}, разделив их запятыми (,). Каждый элемент имеет ключ и значение, выраженное парой «ключ: значение».

# Создание пустого словаря: dict_sample = {}
# dict_sample = {1: 'mango', 2: 'pawpaw'} # когда слова, то в ''
# dict_sample = {'fruit': 'mango', 1: [4, 6, 8]}
# Можно также создать словарь, явно вызвав метод dict():
# dict_sample = dict({1:'mango', 2:'pawpaw'})

# Словари могут быть вложенными. Это значит, что можно создавать словари внутри существующего словаря. 
# dict_sample = {
# 1: {'student1': 'Nicholas', 'student2': 'John', 'student3': 'Mercy'}, 
# 2: {'course1': 'Computer Science', 'course2': 'Mathematics', 'course3': 'Accounting'}
# }
# Чтобы вывести содержимое словаря, можно использовать функцию print() и передать название словаря в качестве аргумента.

# cake = ('c','a','k','e') 
# print(type(cake)) #class 'tuple'

# numbers_tuple = (1,2,3,4,5)
# numbers_list = [1,2,3,4,5]

# Функции кортежей
# В отличие от списков у кортежей нет методов, таких как append(), remove(), extend(), insert() или pop() опять-таки из-за их неизменяемости. Но есть другие:
# count() возвращает количество повторений элемента в кортеже.
# len() — длину кортежа:
# Функцию any() можно использовать, чтобы определить являются ли элементы кортежа итерируемыми. Если да, то она вернет True.
# a = (1,) Обратите внимание на запятую (,)
# Функция tuple() используется для конвертации данных в кортеж. Например, так можно превратить список в кортеж.
# Функция max()q возвращает самый большой элемент последовательности, а min() — самый маленький. Возьмем следующий пример
